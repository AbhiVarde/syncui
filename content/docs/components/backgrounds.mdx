---
title: Backgrounds
description: Sync UI offers a variety of background animation styles to enhance your user interface.
---

Sync UI offers a variety of background animation styles to enhance your user interface and provide visually appealing backgrounds for your components.

#### Gemini Wave

A gradient background with animated wave-like patterns.

<CodePreview
  preview={<BackgroundVariants variant="geminiWave" />}
  code={`
import React from "react";
import { Box, Typography } from "@mui/material";
import { motion } from "motion/react";

const MotionBox = motion.create(Box);

const GeminiWave = () => (
  <MotionBox
    sx={{
      width: "100%",
      height: "100%",
      background: "linear-gradient(135deg, #92EFFD, #4E65FF)",
      position: "relative",
      overflow: "hidden",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
    }}
  >
    <MotionBox
      sx={{
        position: "absolute",
        width: "150%",
        height: "100%",
        left: "-25%",
      }}
    >
      {[0, 1, 2].map((index) => (
        <MotionBox
          key={index}
          sx={{
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            opacity: 0.7 - index * 0.2,
          }}
        >
          <svg
            viewBox="0 0 1440 320"
            style={{
              position: "absolute",
              width: "100%",
              height: "100%",
            }}
          >
            <motion.path
              fill={\`rgba(255,255,255,\${0.3 - index * 0.1})\`}
              initial={{
                d: "M0,160 C320,300,420,240,640,160 C880,80,1200,220,1440,200 V320 H0 Z",
              }}
              animate={{
                d: [
                  "M0,160 C320,300,420,240,640,160 C880,80,1200,220,1440,200 V320 H0 Z",
                  "M0,200 C320,100,420,260,640,200 C880,140,1200,180,1440,240 V320 H0 Z",
                  "M0,160 C320,300,420,240,640,160 C880,80,1200,220,1440,200 V320 H0 Z",
                ],
              }}
              transition={{
                repeat: Infinity,
                duration: 8 - index * 1.5,
                ease: "easeInOut",
              }}
            />
          </svg>
        </MotionBox>
      ))}
    </MotionBox>
    <Typography variant="h4" sx={{ fontWeight: 500, color: "#fff", zIndex: 1 }}>
      Gemini Wave
    </Typography>
  </MotionBox>
);

export default GeminiWave;
`}
/>

#### Gradient Mesh

A dynamic gradient background with multiple color focal points.

<CodePreview
  preview={<BackgroundVariants variant="gradientMesh" />}
  code={`
import React, { useRef } from "react";
import { Box, Typography } from "@mui/material";
import { motion, useInView } from "motion/react";

const MotionBox = motion.create(Box);

const GradientMesh = () => {
  const ref = useRef(null);
  const isInView = useInView(ref, { once: false, amount: 0.3 });

  return (
    <MotionBox
      ref={ref}
      initial={{ opacity: 0 }}
      animate={isInView ? { opacity: 1 } : { opacity: 0 }}
      transition={{ duration: 0.6, ease: "easeOut" }}
      sx={{
        width: "100%",
        height: "100%",
        background: \`
          radial-gradient(at 30% 10%, #6EE7B7 0px, transparent 50%),
          radial-gradient(at 80% 0%, #3B82F6 0px, transparent 50%),
          radial-gradient(at 10% 90%, #F87171 0px, transparent 50%),
          radial-gradient(at 90% 80%, #C084FC 0px, transparent 55%)
        \`,
        backgroundSize: "100% 100%",
        animation: "gradientShift 12s ease infinite",
        "@keyframes gradientShift": {
          "0%, 100%": { backgroundPosition: "0% 0%" },
          "50%": { backgroundPosition: "100% 100%" },
        },
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Typography
        variant="h4"
        sx={{
          fontWeight: 500,
          position: "relative",
          zIndex: 2,
          color: "#fff",
        }}
      >
        Gradient Mesh
      </Typography>
    </MotionBox>
  );
};

export default GradientMesh;
`}
/>

#### Moving Shapes

Animated geometric shapes moving across a gradient background.

<CodePreview
  preview={<BackgroundVariants variant="movingShapes" />}
  code={`
import React, { useMemo } from "react";
import { Box, Typography } from "@mui/material";
import { motion } from "motion/react";

const MotionBox = motion.create(Box);

const MovingShapes = () => {
  const shapes = useMemo(() => {
    const gradients = [
      { start: "#00C853", end: "#B2FF59" },
      { start: "#FF4B2B", end: "#FF416C" },
      { start: "#36D1DC", end: "#5B86E5" },
    ];

    return Array.from({ length: 8 }, (_, index) => ({
      id: index,
      size: [60, 80, 100, 120][index % 4],
      gradient: gradients[index % gradients.length],
      borderRadius: index % 2 === 0 ? "50%" : "30%",
      duration: 12 + index * 1.5,
      left: \`\${(index * 25) % 100}%\`,
      top: \`\${(index * 35) % 100}%\`,
    }));
  }, []);

  return (
    <MotionBox
      sx={{
        width: "100%",
        height: "100%",
        background: "linear-gradient(45deg, #4E65FF, #92EFFD)",
        position: "relative",
        overflow: "hidden",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      {shapes.map((shape) => (
        <MotionBox
          key={shape.id}
          sx={{
            position: "absolute",
            width: shape.size,
            height: shape.size,
            borderRadius: shape.borderRadius,
            background: \`linear-gradient(135deg, \${shape.gradient.start}, \${shape.gradient.end})\`,
            opacity: 0.4,
            filter: "blur(4px)",
            boxShadow: "0 0 20px rgba(0,0,0,0.1)",
          }}
          animate={{
            x: ["-20%", "120%"],
            y: ["-20%", "120%"],
            rotate: [0, 360],
          }}
          transition={{
            duration: shape.duration,
            repeat: Infinity,
            repeatType: "reverse",
            ease: "linear",
          }}
          style={{
            left: shape.left,
            top: shape.top,
          }}
        />
      ))}
      <Typography
        variant="h4"
        sx={{
          color: "#fff",
          zIndex: 1,
          fontWeight: 500,
        }}
      >
        Moving Shapes
      </Typography>
    </MotionBox>
  );
};

export default MovingShapes;
`}
/>

#### Flickering Grid

A grid of squares with random flickering effects.

<CodePreview
  preview={<BackgroundVariants variant="flickeringGrid" />}
  code={`
import React, { useMemo } from "react";
import { Box, Typography, useTheme } from "@mui/material";
import { motion } from "motion/react";

const MotionBox = motion.create(Box);

const FlickeringGrid = () => {
  const theme = useTheme();

  const squareSize = 2;
  const gridGap = 0.5;
  const flickerChance = 0.3;
  const maxOpacity = 0.3;

  const gridSize = useMemo(() => {
    const cols = Math.floor(100 / (squareSize + gridGap));
    const rows = Math.floor(100 / (squareSize + gridGap));
    return { cols, rows };
  }, []);

  const squares = useMemo(() => {
    return Array.from({ length: gridSize.cols * gridSize.rows }, (_, i) => ({
      id: i,
      opacity: Math.random() * maxOpacity,
      shouldFlicker: Math.random() < flickerChance,
    }));
  }, [gridSize]);

  return (
    <MotionBox
      sx={{
        width: "100%",
        height: "100%",
        position: "relative",
        overflow: "hidden",
        background: theme.palette.background.default,
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      {squares.map((square) => (
        <MotionBox
          key={square.id}
          animate={{
            opacity: square.shouldFlicker
              ? [square.opacity, Math.random() * maxOpacity, square.opacity]
              : square.opacity,
          }}
          transition={{
            duration: 1.5,
            repeat: Infinity,
            ease: "easeInOut",
          }}
          sx={{
            position: "absolute",
            width: \`\${squareSize}%\`,
            height: \`\${squareSize}%\`,
            left: \`\${(square.id % gridSize.cols) * (squareSize + gridGap)}%\`,
            top: \`\${Math.floor(square.id / gridSize.cols) * (squareSize + gridGap)}%\`,
            backgroundColor: "#34D399",
          }}
        />
      ))}
      <Typography
        variant="h4"
        sx={{
          fontWeight: 500,
          position: "absolute",
          zIndex: 1,
        }}
      >
        Flickering Grid
      </Typography>
    </MotionBox>
  );
};

export default FlickeringGrid;
`}
/>

#### Interactive Grid

A grid of squares that respond to hover interactions.

<CodePreview
  preview={<BackgroundVariants variant="interactiveGrid" />}
  code={`
import React, { useState, useEffect, useRef } from "react";
import { Box, Typography, useTheme } from "@mui/material";
import { motion } from "motion/react";

const MotionBox = motion.create(Box);

const InteractiveGrid = () => {
  const theme = useTheme();
  const [gridDimensions, setGridDimensions] = useState({ width: 0, height: 0 });
  const [hoveredSquare, setHoveredSquare] = useState(null);
  const containerRef = useRef(null);

  const squareWidth = 30;
  const squareHeight = 30;

  useEffect(() => {
    const calculateGrid = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        const horizontalSquares = Math.floor(rect.width / squareWidth);
        const verticalSquares = Math.floor(rect.height / squareHeight);
        setGridDimensions({
          width: horizontalSquares,
          height: verticalSquares,
        });
      }
    };

    calculateGrid();
    window.addEventListener("resize", calculateGrid);
    return () => window.removeEventListener("resize", calculateGrid);
  }, []);

  const totalSquares = gridDimensions.width * gridDimensions.height;

  return (
    <MotionBox
      ref={containerRef}
      sx={{
        width: "100%",
        height: "100%",
        background: theme.palette.background.default,
        position: "relative",
        overflow: "hidden",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      {gridDimensions.width > 0 && (
        <Box
          sx={{
            position: "relative",
            width: gridDimensions.width * squareWidth,
            height: gridDimensions.height * squareHeight,
            maxWidth: "100%",
            maxHeight: "100%",
            border: "0.5px solid rgba(128, 128, 128, 0.3)",
          }}
        >
          {Array.from({ length: totalSquares }, (_, index) => {
            const x = (index % gridDimensions.width) * squareWidth;
            const y = Math.floor(index / gridDimensions.width) * squareHeight;

            return (
              <MotionBox
                key={index}
                sx={{
                  cursor: "pointer",
                  position: "absolute",
                  top: y,
                  left: x,
                  width: squareWidth,
                  height: squareHeight,
                  border: "0.5px solid rgba(128, 128, 128, 0.3)",
                  backgroundColor:
                    hoveredSquare === index ? "#FF416C" : "transparent",
                }}
                onMouseEnter={() => setHoveredSquare(index)}
                onMouseLeave={() => setHoveredSquare(null)}
                whileHover={{ scale: 1.05 }}
                transition={{ duration: 0.1, ease: "easeOut" }}
              />
            );
          })}
        </Box>
      )}
      <Typography
        variant="h4"
        sx={{
          fontWeight: 500,
          position: "absolute",
          zIndex: 1,
        }}
      >
        Interactive Grid
      </Typography>
    </MotionBox>
  );
};

export default InteractiveGrid;
`}
/>

#### Grid

A simple grid background pattern.

<CodePreview
  preview={<BackgroundVariants variant="grid" />}
  code={`
import React from "react";
import { Box, Typography, useTheme } from "@mui/material";
import { motion } from "motion/react";

const MotionBox = motion.create(Box);

const GridBackground = () => {
  const theme = useTheme();
  return (
    <MotionBox
      sx={{
        width: "100%",
        height: "100%",
        background: theme.palette.background.default,
        backgroundImage:
          "linear-gradient(rgba(128,128,128,0.3) 1px, transparent 1px), linear-gradient(90deg, rgba(128,128,128,0.3) 1px, transparent 1px)",
        backgroundSize: "20px 20px",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Typography variant="h4" sx={{ fontWeight: 500, zIndex: 1 }}>
        Grid
      </Typography>
    </MotionBox>
  );
};

export default GridBackground;
`}
/>

#### Magnetic Connections

Interactive dots that connect to the mouse cursor with magnetic effects.

<CodePreview
  preview={<BackgroundVariants variant="magneticConnections" />}
  code={`
import React, { useState, useEffect, useCallback, useRef } from "react";
import { Box, Typography, useTheme } from "@mui/material";
import { motion } from "motion/react";

const MotionBox = motion.create(Box);

const MagneticConnections = () => {
  const theme = useTheme();
  const [mousePos, setMousePos] = useState(null);
  const [dots, setDots] = useState([]);
  const rafRef = useRef(null);
  const ref = useRef(null);

  const dotSize = 3;
  const spacing = 40;
  const connectDistance = 80;
  const lineOpacity = 0.6;
  const extraColumns = 4;

  useEffect(() => {
    const calculateDots = () => {
      if (ref.current) {
        const width = ref.current.offsetWidth;
        const height = ref.current.offsetHeight;
        const cols = Math.floor(width / spacing) + extraColumns;
        const rows = Math.floor(height / spacing);
        const offsetX =
          (width - (cols - extraColumns) * spacing) / 2 -
          (extraColumns * spacing) / 2;
        const offsetY = (height - rows * spacing) / 2;

        const newDots = [];
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            newDots.push({
              id: \`\${col}-\${row}\`,
              x: offsetX + col * spacing,
              y: offsetY + row * spacing,
            });
          }
        }
        setDots(newDots);
      }
    };

    calculateDots();
    window.addEventListener("resize", calculateDots);
    return () => window.removeEventListener("resize", calculateDots);
  }, []);

  const handleMouseMove = useCallback((e) => {
    if (rafRef.current) cancelAnimationFrame(rafRef.current);

    rafRef.current = requestAnimationFrame(() => {
      if (!ref.current) return;
      const rect = ref.current.getBoundingClientRect();
      setMousePos({
        x: e.clientX - rect.left,
        y: e.clientY - rect.top,
      });
    });
  }, []);

  const handleMouseLeave = useCallback(() => {
    if (rafRef.current) cancelAnimationFrame(rafRef.current);
    setMousePos(null);
  }, []);

  const distance = useCallback((pos1, pos2) => {
    const dx = pos1.x - pos2.x;
    const dy = pos1.y - pos2.y;
    return Math.sqrt(dx * dx + dy * dy);
  }, []);

  return (
    <MotionBox
      ref={ref}
      onMouseMove={handleMouseMove}
      onMouseLeave={handleMouseLeave}
      sx={{
        width: "100%",
        height: "100%",
        background: theme.palette.background.default,
        position: "relative",
        overflow: "hidden",
        cursor: "pointer",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <svg
        width="100%"
        height="100%"
        style={{
          position: "absolute",
          pointerEvents: "none",
        }}
      >
        {mousePos &&
          dots.map((dot) => {
            const dist = distance(mousePos, dot);

            if (dist < connectDistance) {
              const opacity = lineOpacity * (1 - dist / connectDistance);
              return (
                <line
                  key={\`line-\${dot.id}\`}
                  x1={dot.x}
                  y1={dot.y}
                  x2={mousePos.x}
                  y2={mousePos.y}
                  stroke={
                    theme.palette.mode === "dark"
                      ? "rgba(255,255,255,0.8)"
                      : "rgba(0,0,0,0.7)"
                  }
                  strokeWidth={0.6}
                  opacity={opacity}
                />
              );
            }
            return null;
          })}
      </svg>

      {dots.map((dot) => {
        const dist = mousePos ? distance(mousePos, dot) : connectDistance;
        const scale = mousePos
          ? 1 + 0.5 * (1 - Math.min(1, dist / connectDistance))
          : 1;
        const opacity = mousePos
          ? 0.8 + 0.2 * (1 - Math.min(1, dist / connectDistance))
          : 0.8;

        return (
          <motion.div
            key={dot.id}
            style={{
              position: "absolute",
              left: dot.x - dotSize / 2,
              top: dot.y - dotSize / 2,
              width: dotSize,
              height: dotSize,
              borderRadius: "50%",
              background:
                theme.palette.mode === "dark"
                  ? "rgba(255,255,255,0.85)"
                  : "rgba(0,0,0,0.85)",
              zIndex: 1,
              scale,
              opacity,
              willChange: "transform, opacity",
            }}
            transition={{ duration: 0.15, ease: "easeOut" }}
          />
        );
      })}

      <Typography
        variant="h4"
        sx={{
          fontWeight: 500,
          position: "relative",
          zIndex: 2,
        }}
      >
        Magnetic Connections
      </Typography>
    </MotionBox>
  );
};

export default MagneticConnections;
`}
/>

#### Dots

A simple dotted background pattern.

<CodePreview
  preview={<BackgroundVariants variant="dots" />}
  code={`
import React from "react";
import { Box, Typography, useTheme } from "@mui/material";
import { motion } from "motion/react";

const MotionBox = motion.create(Box);

const DotsBackground = () => {
  const theme = useTheme();
  return (
    <MotionBox
      sx={{
        width: "100%",
        height: "100%",
        background: theme.palette.background.default,
        backgroundImage:
          theme.palette.mode === "dark"
            ? "radial-gradient(rgba(255,255,255,0.45) 1px, transparent 1px)"
            : "radial-gradient(rgba(0,0,0,0.45) 1px, transparent 1px)",
        backgroundSize: "20px 20px",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Typography variant="h4" sx={{ fontWeight: 500, zIndex: 1 }}>
        Dots
      </Typography>
    </MotionBox>
  );
};

export default DotsBackground;
`}
/>